<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Limbo&#39;s Wiki</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-20T17:36:05.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Limbo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Class 文件结构</title>
    <link href="http://yoursite.com/wiki/class_bytes/"/>
    <id>http://yoursite.com/wiki/class_bytes/</id>
    <published>2020-01-20T17:36:05.000Z</published>
    <updated>2020-01-20T17:36:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li><a href="https://coolshell.cn/articles/9229.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9229.html</a></li><li><a href="http://luckylau.tech/2017/05/26/你懂java吗-11/" target="_blank" rel="noopener">http://luckylau.tech/2017/05/26/%E4%BD%A0%E6%87%82java%E5%90%97-11/</a></li></ul><p><img src="http://luckylau.tech/2017/05/26/%E4%BD%A0%E6%87%82java%E5%90%97-11/1.png" alt="img"></p><h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p>0XCAFEBABE </p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><p><img src="http://luckylau.tech/2017/05/26/%E4%BD%A0%E6%87%82java%E5%90%97-11/18.png" alt="img"></p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200121013404.png" alt=""></p><p><img src="http://luckylau.tech/2017/05/26/%E4%BD%A0%E6%87%82java%E5%90%97-11/4.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://coolshell.cn/articles/9229.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://coolshell.cn/articles/9229.html
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JVM Memory</title>
    <link href="http://yoursite.com/wiki/Language/Java/jvm/jvm_mem/"/>
    <id>http://yoursite.com/wiki/Language/Java/jvm/jvm_mem/</id>
    <published>2020-01-20T16:00:12.000Z</published>
    <updated>2020-01-20T16:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_mem_1.png" alt=""></p><p>JVM 主要三个组成:</p><ul><li>Heap: 所有实例对象, 堆内空间无法扩展出现 OOM 异常<ul><li>Young Generation(默认比例 8:1:1)<ul><li>Eden</li><li>From Survivor</li><li>To Survivor</li></ul></li><li>Old Generation</li></ul></li><li>Method Area(<code>Non-Heap, PermGen, 永久代</code>): 方法区存储类信息, 常量, 静态变量等数据, 线程共享区域, 方法区也会抛出 OOM</li><li>Stack<ul><li>Java Stack: 每个方法执行的时候都会创建一个 stack frame, 保存局部变量, 操作栈,动态链接, 方法出口等, 如果线程请求栈的深度大于虚拟机允许深度, 抛出 stackoverflow 异常, 如果虚拟机栈可以动态扩展, 当无法申请内存是会抛出 OOM 异常</li><li>Native Method Stack: 存一些原生方法, C 库</li></ul></li></ul><h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_mem_2.png" alt=""></p><h2 id="其他内存占用"><a href="#其他内存占用" class="headerlink" title="其他内存占用"></a>其他内存占用</h2><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO使用java.nio.ByteBuffer.allocateDirect()方法分配内存，每次分配内存都会调用操作系统函数os::malloc()，所以，分配的内存是本机的内存而不是Java堆上的内存；</p><p> 另外利用该方法产生的数据和网络、磁盘发生交互的时候都是在内核空间发生的，不需要复制到用户空间Java内存中，这种技术避免了Java堆和本机堆之间的数据复制；但是利用该方法生成的数据会作为Java堆GC的一部分来自动清理本机缓冲区。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/20200120235923.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_mem_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;JVM 主要三个组成:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Heap: 所有实例对
      
    
    </summary>
    
    
      <category term="Language" scheme="http://yoursite.com/categories/Language/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Language/Java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/categories/Language/Java/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>欢迎来到我的 Wiki</title>
    <link href="http://yoursite.com/wiki/index/"/>
    <id>http://yoursite.com/wiki/index/</id>
    <published>2020-01-20T15:45:04.000Z</published>
    <updated>2020-01-20T15:45:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直在找代替 Blog 的工具, 发现 Wiki 更适合知识体系的构建, 经常性的总结比记流水帐更有效果</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直在找代替 Blog 的工具, 发现 Wiki 更适合知识体系的构建, 经常性的总结比记流水帐更有效果&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/wiki/BigData/Kafka/cheat_sheet/"/>
    <id>http://yoursite.com/wiki/BigData/Kafka/cheat_sheet/</id>
    <published>2020-01-15T12:06:59.175Z</published>
    <updated>2020-01-15T12:06:59.175Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="BigData" scheme="http://yoursite.com/categories/BigData/"/>
    
      <category term="Kafka" scheme="http://yoursite.com/categories/BigData/Kafka/"/>
    
    
  </entry>
  
  <entry>
    <title>crontab</title>
    <link href="http://yoursite.com/wiki/Linux/crontab/"/>
    <id>http://yoursite.com/wiki/Linux/crontab/</id>
    <published>2020-01-15T12:06:59.174Z</published>
    <updated>2020-01-15T12:12:26.138Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[xuxiao.xu@l-rtools1.ops.cna ~]$ cat /etc/crontab</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"></span><br><span class="line"><span class="comment"># For details see man 4 crontabs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name  command to be executed</span></span><br></pre></td></tr></table></figure><p><a href="https://crontab.guru/" target="_blank" rel="noopener">https://crontab.guru/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>包管理系统</title>
    <link href="http://yoursite.com/wiki/Linux/package/"/>
    <id>http://yoursite.com/wiki/Linux/package/</id>
    <published>2020-01-15T12:06:59.173Z</published>
    <updated>2020-01-21T08:38:45.551Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/package_management.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/img/master/img/package_management.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Maven 汇总</title>
    <link href="http://yoursite.com/wiki/Language/Java/maven/"/>
    <id>http://yoursite.com/wiki/Language/Java/maven/</id>
    <published>2020-01-15T12:06:59.168Z</published>
    <updated>2020-01-15T12:06:59.169Z</updated>
    
    <content type="html"><![CDATA[<p>Maven 是常用的 Java 构建工具, 以 POM 文件为中心,  Maven 工作时的几个主要步骤</p><ol><li>读取 pom.xml</li><li>下载依赖到本地</li><li>执行构建过程</li><li>执行插件</li></ol><h1 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h1><p>POM - Project Object Model 具体可参见 <a href="http://maven.apache.org/guides/introduction/introduction-to-the-pom.html" target="_blank" rel="noopener">官网 POM 介绍</a></p><h1 id="依赖包管理"><a href="#依赖包管理" class="headerlink" title="依赖包管理"></a>依赖包管理</h1><ol><li>Maven 会递归下载 POM 文件中的依赖, 可以用 <code>&lt;exclusions&gt;</code> 进行排除</li><li>Maven 下载的依赖来自 3 个地方:<ul><li>本地 <code>%USER_HOME%/.m2</code> 目录</li><li>中央仓库</li><li>远程库</li></ul></li></ol><h1 id="理解-Lifecycle-Phase-Goal"><a href="#理解-Lifecycle-Phase-Goal" class="headerlink" title="理解 Lifecycle, Phase, Goal"></a>理解 Lifecycle, Phase, Goal</h1><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/POM.png" alt=""></p><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>上面图里可以看到 Maven 自带 3 个 Lifecycle:</p><ul><li>default: 主要生命周期, 编译代码并处理打包项目</li><li>clean: 清理构建输出, 包括中间文件</li><li>site: 文档生成</li></ul><h2 id="Phase"><a href="#Phase" class="headerlink" title="Phase"></a>Phase</h2><p><code>default</code> 的 Lifecycle 包含了许多 phase, 常见如下, 完整可以查看 <a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference" target="_blank" rel="noopener">Lifecycle Referrence</a></p><ul><li>validate: 验证项目</li><li>compile: 编译代码</li><li>test: 测试</li><li>package: 将编译后代码打包</li><li>install: 安装到本地存储</li><li>deploy: 发布到远程仓库</li></ul><p>当我们执行 <code>mvn install</code> 时, 实际会按照顺序执行前置的各个 phase, 例如 validate -&gt; compile -&gt; test -&gt; package -&gt; install 最终执行到 install</p><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>Maven 为插件提供了 Goal 来注册到各个 phase 进行执行</p><h2 id="Maven-是如何组合这些过程的"><a href="#Maven-是如何组合这些过程的" class="headerlink" title="Maven 是如何组合这些过程的"></a>Maven 是如何组合这些过程的</h2><p>在 POM 中有一个 <code>&lt;packaging&gt;</code> 选项, 默认会是 <code>jar</code>, 这个 <code>packaging</code> 会绑定一些 <code>goal</code> 到各个 <code>phase</code>, 默认可查看 <a href="http://maven.apache.org/ref/3.6.2/maven-core/default-bindings.html" target="_blank" rel="noopener">Plugin Bindings</a>, 举个例子 <code>jar</code> 的默认绑定:</p><table><thead><tr><th align="left">Phase</th><th align="left">plugin:goal</th></tr></thead><tbody><tr><td align="left">process-resources</td><td align="left">resources:resources</td></tr><tr><td align="left">compile</td><td align="left">compiler:compile</td></tr><tr><td align="left">process-test-resources</td><td align="left">resources:testResources</td></tr><tr><td align="left">test-compile</td><td align="left">compiler:testCompile</td></tr><tr><td align="left">test</td><td align="left">surefire:test</td></tr><tr><td align="left">package</td><td align="left">jar:jar</td></tr><tr><td align="left">install</td><td align="left">install:install</td></tr><tr><td align="left">deploy</td><td align="left">deploy:deploy</td></tr></tbody></table><p>Maven 在按照 lifecycle 进行运行的时候会执行各个 phase 中的 goal</p><h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>如果我们想要在不同阶段对打包进行控制, 可以设置 scope 参数, <a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Scope" target="_blank" rel="noopener">官网</a></p><p>对应不通的编译阶段我们可以参考下图</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/scope.png" alt=""></p><ul><li>compile: 默认设置, 参与整个打包的周期</li><li>provided: 比如说我们提交 Flink 任务到集群里, 很多包集群是已经附带的, 我们就可以把该包设置成 provided, 减少打包体积</li><li>runtime: 这个一般用 jdbc 可以选填, 只有在运行时才需要</li><li>test: 测试阶段用到的包</li><li>system: 从本地引用包, 不会去仓库下载, 配合 systemPath 使用</li></ul><p>对于依赖的传递, 可以举例:</p><p>A - comiple -&gt; B - provided -&gt; C 或者<br>A - comiple -&gt; B - test -&gt; C 时 A 将丢弃 C, 不会引用</p><p>下面是具体的引用传递:</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/scope_depedency.png" alt=""></p><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul><li><a href="https://maven.apache.org/index.html" target="_blank" rel="noopener">Maven 官网</a></li><li><a href="https://www.qikegu.com/docs/2454" target="_blank" rel="noopener">Maven 教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Maven 是常用的 Java 构建工具, 以 POM 文件为中心,  Maven 工作时的几个主要步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读取 pom.xml&lt;/li&gt;
&lt;li&gt;下载依赖到本地&lt;/li&gt;
&lt;li&gt;执行构建过程&lt;/li&gt;
&lt;li&gt;执行插件&lt;/li&gt;
&lt;/ol&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="Language" scheme="http://yoursite.com/categories/Language/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Language/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM 简介 (翻译)</title>
    <link href="http://yoursite.com/wiki/Language/Java/jvm/jvm/"/>
    <id>http://yoursite.com/wiki/Language/Java/jvm/jvm/</id>
    <published>2020-01-15T12:06:59.168Z</published>
    <updated>2020-01-15T12:06:59.168Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.guru99.com/java-virtual-machine-jvm.html" target="_blank" rel="noopener">https://www.guru99.com/java-virtual-machine-jvm.html</a></p><h2 id="什么是-JVM"><a href="#什么是-JVM" class="headerlink" title="什么是 JVM ?"></a>什么是 JVM ?</h2><p>Java Virtual Machine (JVM) 是提供 Java 代码和应用运行环境的引擎. 它可以将 Java 字节码转换成机器码. JVM 是 Java Run Environment (JRE) 的一部分. 在其他语言里, 编译器为特定的系统产生机器码, 然而, Java 编译器产生的代码直接提供给虚拟机, 就是我们熟知的 JVM</p><h3 id="JVM-如何工作"><a href="#JVM-如何工作" class="headerlink" title="JVM 如何工作"></a>JVM 如何工作</h3><p>首先, Java 代码编译成字节码. 这个字节码可以在不同的机器上解析.</p><p>字节码是介于主机系统和 Java 源码之间的中间语言.</p><p>JVM 负责分配内存空间</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_work.png" alt=""></p><h2 id="JVM-架构"><a href="#JVM-架构" class="headerlink" title="JVM 架构"></a>JVM 架构</h2><p>让我们来了解下 JVM 的架构. 它包含了 classloader, memory area, execution egine 等.</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_arch.png" alt=""></p><ol><li>ClassLoader: 类加载器是一个加载类文件的子系统, 包括 3 个主要功能, Loading, Linking 和 Initialization</li><li>Method Area: JVM 方法区保存像 metadata, 持久的运行池和代码方法</li><li>Heap: 所有的 Object, 他们相关的 instance 变量, 数组都存在 heap 里, 这些内存可以在不同线程间分享</li><li>JVM Language Stacks: 存储 local 变量, 和一部分结果. <strong><em>每个线程都有自己的 JVM stack</em></strong>, 创建线程的同时它们也会被创建. 当一个方法被 invoke 时, 新的 frame 就会被创建, 当方法 invocation process 完成时也就会被删除.</li><li>PC Registers: 保存正在执行的代码地址. 在 Java 中, <strong><em>每个线程有自己的 PC register</em></strong>.</li><li>Native Method Stacks: 保存原生库的地方. 通常都是其他语言的代码.</li><li>Execution Engine: It is a type of software used to test hardware, software, or complete systems. The test execution engine never carries any information about the tested product.</li><li>Native Method interface: 编程框架. 允许 Java 代码在 JVM 里调用库和原生应用.</li><li>Native Method Libraries: Execution Engine 需要的一些原生库(C, C++)</li></ol><h2 id="代码编译和执行过程"><a href="#代码编译和执行过程" class="headerlink" title="代码编译和执行过程"></a>代码编译和执行过程</h2><p>为了书写和执行一个软件, 你需要:</p><ol><li>Editor: 输入你的代码</li><li>Compile: 讲你的高级语言转换成机器语言</li><li>Linker: 将不同的程序文件合并在你的 main 程序里.</li><li>Loader: 讲文件从硬盘里加载到 RAM 里. Loading 的过程是在执行代码的时候自动执行的</li><li>Execution: 通过操作系统和进程来执行你的代码</li></ol><h2 id="C-代码编译和执行过程"><a href="#C-代码编译和执行过程" class="headerlink" title="C 代码编译和执行过程"></a>C 代码编译和执行过程</h2><p>为了理解 Java 编译过程, 先让我们简单看一下 C 语言是如何编译和链接的</p><p>假设你的 main 函数里调用了 f1 和 f2 两个函数. main 函数保存在 a1.c 文件里</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_c_1.png" alt=""></p><p>f1 函数保存在 a2.c 文件里</p><p>f2 函数保存在 a3.c 文件里</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_c_3.png" alt=""></p><p>所有文件, a1.c, a2.c 和 a3.c 通过 compiler 输出为机器码</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_c_4.png" alt=""></p><p>下一步就是通过 linker 将所有这些 object 文件打包成一个 exe 文件</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_c_5.png" alt=""></p><p>在程序运行期间, 一个 loader 程序将会把 a.exe load 进 Ram 里来执行</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_c_6.png" alt=""></p><h2 id="Java-代码在-JVM-里编译和执行"><a href="#Java-代码在-JVM-里编译和执行" class="headerlink" title="Java 代码在 JVM 里编译和执行"></a>Java 代码在 JVM 里编译和执行</h2><p>让我们看看 Java 程序. 在你的 main 函数里有 f1 , f2 两个函数</p><ul><li>main 方法存在 a1.java 文件</li><li>f1 存在 a2.java 文件</li><li>f2 存在 a3.java 文件</li></ul><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_java_1.png" alt=""></p><p>compiller 将会产出 3 个以 .class 命名的字节码文件. 不像 C, 没有 linking 的过程.</p><p>JVM 存在于 RAM 中. 在执行期间, 使用 class loader 把 class 文件装载进 RAM, </p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_java_2.png" alt=""></p><p>下一步,  execution engine 将会把字节码转换为机器码,这是在 compile 时候进行的. 这就是为什么相对来说 Java 运行的比较慢.</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/jvm_java_3.png" alt=""></p><p>NOTE: JIT 或者说 Just-in-time compiler 是 JVM 的一部分. It interprets part of the Byte Code that has similar functionality at the same time.</p><h2 id="为什么-Java-既是解析又是编译语言"><a href="#为什么-Java-既是解析又是编译语言" class="headerlink" title="为什么 Java 既是解析又是编译语言?"></a>为什么 Java 既是解析又是编译语言?</h2><p>程序语言分类</p><ul><li>高级语言: C++, Java</li><li>中等语言: C</li><li>低级语言: Assembly</li><li>最低级语言: 机器语言</li></ul><p>compiler 可以将一个程序从一级语言转化为另一级语言, 例如将 C++ 转为机器语言</p><p>java compiler 将高级的 java 代码转换为字节码(也是一种机器码)</p><p>interpreter 可以将同一级别的语言转化为相同级别的语言.例如 Java 程序转换为 C++</p><p>在 Java 中 JIT 将字节码转换为机器码是相同语言级别的转换</p><p>所以, Java 既是解析又是编译语言</p><h2 id="为什么-Java-慢"><a href="#为什么-Java-慢" class="headerlink" title="为什么 Java 慢?"></a>为什么 Java 慢?</h2><p>主要两个原因:</p><ol><li>动态链接: 不像 C, Java 在运行时链接</li><li>运行时解析: 字节码是在运行时转换为机器码. 所以速度有所减慢</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.guru99.com/java-virtual-machine-jvm.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.guru99.com/java-virtual-machine
      
    
    </summary>
    
    
      <category term="Language" scheme="http://yoursite.com/categories/Language/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Language/Java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/categories/Language/Java/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>RAID</title>
    <link href="http://yoursite.com/wiki/Hardware/Disk/raid/"/>
    <id>http://yoursite.com/wiki/Hardware/Disk/raid/</id>
    <published>2020-01-15T12:06:59.165Z</published>
    <updated>2020-01-15T12:06:59.165Z</updated>
    
    <content type="html"><![CDATA[<p>RAID是英文Redundant Array of Independent Disks的缩写, 即磁盘冗余阵列.</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/raid.png" alt=""></p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/raid_table.png" alt=""></p><h2 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h2><p>分散打在不同磁盘上, 写入速度 * n</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/raid0.png" alt=""></p><h2 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h2><p>镜像对考， 双写</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/raid1.png" alt=""></p><h2 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h2><p>校验块分布在不同磁盘上, 易于扩展</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/raid5.png" alt=""></p><h2 id="Raid-6"><a href="#Raid-6" class="headerlink" title="Raid 6"></a>Raid 6</h2><p>采用两种独立的校验算法</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/raid6.png" alt=""></p><h2 id="RAID-组合"><a href="#RAID-组合" class="headerlink" title="RAID 组合"></a>RAID 组合</h2><p>组合方式, 速度既快, 又有备份</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/raid01.png" alt=""></p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/raid10.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RAID是英文Redundant Array of Independent Disks的缩写, 即磁盘冗余阵列.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/img/master/img/ra
      
    
    </summary>
    
    
      <category term="Hardware" scheme="http://yoursite.com/categories/Hardware/"/>
    
      <category term="Disk" scheme="http://yoursite.com/categories/Hardware/Disk/"/>
    
    
  </entry>
  
  <entry>
    <title>硬盘接口</title>
    <link href="http://yoursite.com/wiki/Hardware/Disk/interface/"/>
    <id>http://yoursite.com/wiki/Hardware/Disk/interface/</id>
    <published>2020-01-15T12:06:59.165Z</published>
    <updated>2020-01-15T12:06:59.165Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center">名称</th><th align="center">总线</th><th align="center">物理接口</th><th>协议</th><th>年份</th><th>带宽</th><th>理论速度</th><th>编码</th></tr></thead><tbody><tr><td align="center">SATA 1.0</td><td align="center">SATA</td><td align="center">SATA</td><td>AHCI</td><td>2003</td><td>1.5 Gb/s</td><td>150 MB/s</td><td>8 b / 10 b</td></tr><tr><td align="center">SATA 2.0</td><td align="center">SATA</td><td align="center">SATA</td><td>AHCI</td><td>2004</td><td>3 Gb/s</td><td>300 MB/s</td><td>8 b / 10 b</td></tr><tr><td align="center">SATA 3.0</td><td align="center">SATA</td><td align="center">SATA</td><td>AHCI</td><td>2009</td><td>6 Gb/s</td><td>600 MB/s</td><td>8 b / 10 b</td></tr><tr><td align="center">SATA Express(SATA 3.2)</td><td align="center">SATA</td><td align="center">SATA</td><td></td><td>2014</td><td>16 Gb/s</td><td>1969 MB/s</td><td>128 b / 130 b</td></tr><tr><td align="center">M.2 SATA</td><td align="center">SATA</td><td align="center">M.2</td><td>AHCI</td><td>2013</td><td>6 Gb/s</td><td>600 MB/s</td><td></td></tr><tr><td align="center">M.2 NVMe</td><td align="center">NVMe</td><td align="center">M.2</td><td>PCIe</td><td>2013</td><td>32 Gb/s</td><td>3200 MB/s</td><td></td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/interface.png" alt=""></p><p>上面这个图有点问题, Technology 那一行的 SATA 都改为 AHCI</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;名称&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;总线&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;物理接口&lt;/th&gt;
&lt;th&gt;协议&lt;/th&gt;
&lt;th&gt;年份&lt;/th&gt;
&lt;th&gt;带宽&lt;/th&gt;

      
    
    </summary>
    
    
      <category term="Hardware" scheme="http://yoursite.com/categories/Hardware/"/>
    
      <category term="Disk" scheme="http://yoursite.com/categories/Hardware/Disk/"/>
    
    
  </entry>
  
  <entry>
    <title>Wi-Fi 协议</title>
    <link href="http://yoursite.com/wiki/Hardware/wifi/"/>
    <id>http://yoursite.com/wiki/Hardware/wifi/</id>
    <published>2020-01-15T12:06:59.164Z</published>
    <updated>2020-01-15T12:06:59.164Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center">名称</th><th align="center">代号</th><th align="center">年代</th><th align="center">频段</th><th align="center">带宽</th></tr></thead><tbody><tr><td align="center">802.11b</td><td align="center">Wi-Fi 1</td><td align="center">1999</td><td align="center">2.4 GHz</td><td align="center">11 Mbps</td></tr><tr><td align="center">802.11a</td><td align="center">Wi-Fi 2</td><td align="center">1999</td><td align="center">5 GHz</td><td align="center">54 Mbps</td></tr><tr><td align="center">802.11g</td><td align="center">Wi-Fi 3</td><td align="center">2003</td><td align="center">2.4 GHz</td><td align="center">54 Mbps</td></tr><tr><td align="center">802.11n</td><td align="center">Wi-Fi 4</td><td align="center">2009</td><td align="center">2.4 GHz / 5 GHz</td><td align="center">450 Mbps</td></tr><tr><td align="center">802.11ac</td><td align="center">Wi-Fi 5</td><td align="center">2014</td><td align="center">2.4 GHz / 5 GHz</td><td align="center">866.7 Mbps</td></tr><tr><td align="center">802.11ax</td><td align="center">Wi-Fi 6</td><td align="center">2019</td><td align="center">2.4 GHz / 5 GHz</td><td align="center">1201 Mbps</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;名称&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;代号&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;年代&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;频段&lt;/th&gt;
&lt;th align=&quot;
      
    
    </summary>
    
    
      <category term="Hardware" scheme="http://yoursite.com/categories/Hardware/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/wiki/Blog/hello-world/"/>
    <id>http://yoursite.com/wiki/Blog/hello-world/</id>
    <published>2020-01-15T12:06:59.162Z</published>
    <updated>2020-01-20T16:16:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="Blog" scheme="http://yoursite.com/categories/Blog/"/>
    
    
  </entry>
  
  <entry>
    <title>Flink 如何工作的?</title>
    <link href="http://yoursite.com/wiki/BigData/flink/"/>
    <id>http://yoursite.com/wiki/BigData/flink/</id>
    <published>2019-12-17T12:19:05.000Z</published>
    <updated>2020-01-15T12:06:59.175Z</updated>
    
    <content type="html"><![CDATA[<p>Flink 是如何工作的?</p><p>本文主要分为两个部分, 分别介绍 Flink 集群的启动和 Flink 任务如何运行在集群中(Stream 方式), 由于篇幅有限, 本文尽量不探讨具体的实现细节,但是比较重要的部分给予一定的说明, 更多的是让读者了解 Flink 内部的工作原理.</p><p>Flink 在部署上主要分为两部分 JobManager 和 TaskManager, JobManager 主要负责任务的分发, slot 资源管理等, TaskManager 则主要负责任务的运行. 下面这张官网的架构图虽然年代有点久远, 但至今大部分功能还是如图所述.</p><p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.9/fig/processes.svg" alt=""></p><p>从上面图中需要了解的信息:</p><ol><li>Flink 代码在客户端里进行了”编译”, 然后提交给 JobManager, 这里比较重要, 因为很多 Optimizer 的东西都可以在这里做</li><li>JobManager 拿到”编译”后的 job 再分发到各个 TaskManager 的 Slot 里</li><li>Flink 有两种通信方式, 远程调用使用的是 Actor, TaskManager 数据传输使用的是 Netty</li><li>JobManager 集成了 Scheduler 和 Checkpoint Coordinator 等主要功能 </li></ol><h1 id="1-Flink-集群的启动"><a href="#1-Flink-集群的启动" class="headerlink" title="1 Flink 集群的启动"></a>1 Flink 集群的启动</h1><p>Flink 集群的启动方式主要分为以下 3 种:</p><ol><li>Standalone 方式: 最基础的方式, 具有完整的功能, 可在实体机上进行部署</li><li>Cluster session 方式: 部署在像 Yarn , K8s 等资源调度框架内, 直接建立起集群, 然后通过与 JobManager 交互来提交作业, 但是在实际生产过程中发现有严重的 Bug 还没有解决,  可参看 <a href="https://issues.apache.org/jira/browse/FLINK-11205" target="_blank" rel="noopener">FLINK-11205</a> , 主要是 Metaspace 空间无法释放导致 TaskManager 被 kill, 而一个集群里存在多个 TaskManager 问题更加严重, 会导致整个集群 Taskmanager 不断重启.</li><li>Per Job 方式: 在 Yarn 中已经很好的集成了这种方式, 就是整个集群的生命周期和任务进行绑定, 任务结束, 集群资源也随着撤销, 唯一的缺点就是部署时间上不如 Cluster session 的方式, 这点其实在实际生产中可以忽略.</li></ol><h2 id="1-1-JobManager-的启动"><a href="#1-1-JobManager-的启动" class="headerlink" title="1.1 JobManager 的启动"></a>1.1 JobManager 的启动</h2><p>因为版本变动的关系 Jobmanager 在 1.5 版本的时候进行了一次大改, 和上面的图可能略有不通, 具体可以参见 <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=65147077" target="_blank" rel="noopener">FLIP-6</a>, 下面聊一聊一般生产中 JobManager 如何启动的.</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/source_global.png" alt=""></p><p>上图可以看出在 1.5 以后的新版本中 JobManager 多出了两个组件, 一个是 ResourceManager, 主要负责管理 Flink 自己的 TaskManager 资源, 注意这个 ResourceManager 和 Yarn 上的不是同一个, 两者管理的资源不是同一级别, 第二个是 Dispatcher 主要是提供 client 的 RPC 接口, 提供发布任务的一系列功能. 而 JobMaster 主要负责一个任务的生命周期, 每个 Flink Job 都有一个 JobMaster 与之对应.</p><h2 id="1-2-TaskManager-的启动"><a href="#1-2-TaskManager-的启动" class="headerlink" title="1.2 TaskManager 的启动"></a>1.2 TaskManager 的启动</h2><p>TaskManager 其实功能比较简单, 提供一些基本的 RPC 服务, 供 JobManager 进行调度, 稍后会讲到 TaskManager 如何运行 JobManager 提供的 subTask.</p><h1 id="2-Flink-Job-的启动"><a href="#2-Flink-Job-的启动" class="headerlink" title="2 Flink Job 的启动"></a>2 Flink Job 的启动</h1><p>我们先来看看一个 Flink job 的构成</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/flink_job.png" alt=""></p><p>Flink job 最核心的构成其实就是这个 ENV, 用户需要通过调用 ENV 来注册用户的代码逻辑, 而这个 ENV 定义了一系列 DAG 生成的规则, 比如 env.addSource 我们必须指定 Source 的类型, 是 DataStream 还是 DataSet, 又比如 keyBy 之后返回的是 KeyedStream, 这些规则都是在 ENV 里进行了定义, 用户只要根据规则来使用即可, 而且根据 ENV 的定义我们可以在不同的环境中运行 Flink Job, 如下图所示:</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/flink_job_env.png" alt=""></p><p>我们可以以 Flink 开发者的角度思考如何从用户代码到底层实现, 这一过程必然使用分层结构, 下面来看一下各个层级的工作:</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/graph_all.png" alt=""></p><h2 id="2-1-Client-端"><a href="#2-1-Client-端" class="headerlink" title="2.1 Client 端"></a>2.1 Client 端</h2><p>首先在 Client 端生成的第一层是 User Rule, 这个算是用户代码到 DAG 的第一层抽象, 这里面制定了很多规则, 来约束用户的行为, 引导用户更好的使用 Flink 程序.</p><p>第二层是 Transformation 层, 这里的 Transformation 主要是完成了对用户的各个算子的定义, 比如说 addSource 的操作即为 SourceTransformation, filter 操作即为 OneInputTransformation, 这里面与用户的算子一一对应, 但是这里面区分定义了 PhysicalTransformation,  PhysicalTransformastion 可以理解为物理算子, 需要计算资源进行计算, 而 union, select 这些并非物理算子, 可以在后面的结构中通过网络 shuffle 进行合并, 在这一步我们得到的还是一个 Transformation 的列表, 完整的描述了用户定义的各个算子, 如下图所示:</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/source_streamGraph.jpg" alt=""></p><p>第三层就是我们的 StreamGraph 了, 从 Transformation 转化而来, 构成了图的结构, 其中 StreamNode 为点, StreamEdge 为边, 在程序里存入的部分是一张链表结构, 如下图所示:</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/source_streamGraph2.jpg" alt=""></p><p>这里面加入了一些信息, 比如说 slotSharingGroup, 从而定义这些算子如何在 slot 里分配</p><p>在 Client 里生成的最后一层即为 JobGraph, 这也是 Flink JobManager 接收的任务对象, 其实上一层的 StreamGraph 已经完成了任务 DAG , 为什么还需要 JobGraph 呢, 其实是为了兼容 Batch 模式, JobGraph 作为统一层进行封装, 同时提供了计算优化即 setChain 功能,  可以减小序列化和网络开销,  可能有的同学会对 chain 的概念有所疑惑 , 比如说 map 算子后面接入一个 filter 算子, 而且是同等数量的, 这样我就可以把 map 和 filter 抽象成一个计算进行自动优化, 要达到 chain 的条件比较苛刻, 具体可以查看代码</p><p>在 JobGraph 里主要结构就是 JobVertex 和 JobEdge, 在前面所说的 chain 方法后, 可以合并 两个或多个 StreamNode 为一个 JobVertex, 如下图所示:</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/source_jobGraph.jpg" alt=""></p><p>好了这里基本就聊完了 Client 端的工作</p><h2 id="2-2-JobManager-端"><a href="#2-2-JobManager-端" class="headerlink" title="2.2 JobManager 端"></a>2.2 JobManager 端</h2><p>JobManager 端接收到 client 提交的 JobGraph, 根据 JobgRaph 来生成 ExcutionGraph, 这个 ExcutionGraph 简单来说就是 JobGraph 的并行版本, 定义具体执行的细节:</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/source_executionGraph.jpg" alt=""></p><p>这里省略了一部分(其他部分一样), 主要来看看几个结构, ExecutionJobVertex 主要类似于 JobGraph 的 Node, 管理所有下面的并行状态, ExecutionVertex 是最小的执行单位(也是我们所说的 SubTask, 每个 SubTask 都由一个 thread 启动), 同理 IntermediateResult 负责多个 IntermediateResultPartition. 到这里完成了 ExecutionGraph, 而需要部署到 TaskManager 中间还需要为每个 Vertex 生成 TaskDeploymentDescriptor, 来描述在 TaskManager 中的具体任务, 比如 inputGates(输入), producedPartition(输出), 然后提交给 TaskManager</p><h2 id="2-3-TaskManager-端"><a href="#2-3-TaskManager-端" class="headerlink" title="2.3 TaskManager 端"></a>2.3 TaskManager 端</h2><p>上面提到 JobManager 生成 TaskDeploymentDescriptor 提交给 TaskManager, TaskManager 就比较好办了, 只需要设定这个 Task 的输入和输出还有 run 这个 Task 即可, 这一层就是所谓的物理执行层.</p><p>而对于分布在各个 TaskManager 上的 SubTask 是如何通信的呢, 可以看下图:</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/image2019-10-14_11-34-38.png" alt=""></p><p>对于在同一个 TaskManager 内的 subTask, 通过 InputGate 和 ResultPartition 直接进行通信, 而对于不在同一个 TaskManager 里需要借助 Netty 层进行网络通信:</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/image2019-10-14_11-33-31.png" alt=""></p><p>还有一点值得注意的是, 当有消息来到时 ResultPartition 会给 InputGate 发送 notifyDataAvallable, 告诉下游该来取数了, 如果下游比较忙没空来取的话就会阻塞, 进而逐级向上传导产生被压, 这种缓冲 buffer 的方式是 flink 天然处理被压的方法.</p><p>至此整个 Flink Job 的流程已经结束, 但毕竟 Flink 是一个庞大的开源项目, 很多细节比如 Checkpoint 机制, 状态存储这些重要的概念还未涉及, 有兴趣的读者可以参考优秀的 Blog 进一步研究</p><p>参考资料:</p><ol><li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/" target="_blank" rel="noopener">Flink 官网</a></li><li><a href="https://cwiki.apache.org/confluence/display/FLINK/Flink+Improvement+Proposals" target="_blank" rel="noopener">FLIP</a></li><li><a href="http://wuchong.me/" target="_blank" rel="noopener">Jark’s Blog</a></li><li><a href="http://chenyuzhao.me/" target="_blank" rel="noopener">玉兆的博客</a></li><li><a href="https://flink.apache.org/2019/06/05/flink-network-stack.html" target="_blank" rel="noopener">Flink 官方博客</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Flink 是如何工作的?&lt;/p&gt;
&lt;p&gt;本文主要分为两个部分, 分别介绍 Flink 集群的启动和 Flink 任务如何运行在集群中(Stream 方式), 由于篇幅有限, 本文尽量不探讨具体的实现细节,但是比较重要的部分给予一定的说明, 更多的是让读者了解 Flink 
      
    
    </summary>
    
    
      <category term="BigData" scheme="http://yoursite.com/categories/BigData/"/>
    
    
  </entry>
  
  <entry>
    <title>黑苹果原理</title>
    <link href="http://yoursite.com/wiki/Hackintosh/principel/"/>
    <id>http://yoursite.com/wiki/Hackintosh/principel/</id>
    <published>2019-12-08T12:19:05.000Z</published>
    <updated>2020-01-15T12:06:59.170Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统正常启动方式为 UEFI 或者 BIOS, 苹果因为需要各种验证所以中间需要进行一层 mock, 就是常见的 Clover</p><p>UEFI -&gt; Clover -&gt; Mac OS</p><p>所以说如果弄黑苹果最主要的是调整好苹果的 EFI 即可, 理论上可以无痛更新</p><p><a href="https://github.com/daliansky/Hackintosh" target="_blank" rel="noopener">https://github.com/daliansky/Hackintosh</a> 收集各种型号主机的 EFI</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://post.smzdm.com/p/a78enm0g/" target="_blank" rel="noopener">关于黑苹果你必须要知道的事儿</a></li><li><a href="https://www.tonymacx86.com/" target="_blank" rel="noopener">tonymacx86</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;操作系统正常启动方式为 UEFI 或者 BIOS, 苹果因为需要各种验证所以中间需要进行一层 mock, 就是常见的 Clover&lt;/p&gt;
&lt;p&gt;UEFI -&amp;gt; Clover -&amp;gt; Mac OS&lt;/p&gt;
&lt;p&gt;所以说如果弄黑苹果最主要的是调整好苹果的 EFI 即
      
    
    </summary>
    
    
      <category term="Hackintosh" scheme="http://yoursite.com/categories/Hackintosh/"/>
    
    
  </entry>
  
  <entry>
    <title>UEFI 与 BIOS</title>
    <link href="http://yoursite.com/wiki/Hackintosh/uefi_bios/"/>
    <id>http://yoursite.com/wiki/Hackintosh/uefi_bios/</id>
    <published>2019-12-08T12:19:05.000Z</published>
    <updated>2020-01-15T12:06:59.170Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/maxresdefault.jpg" alt=""></p><ol><li>1980s 开始 BIOS 系统</li><li>应对 BIOS 限制, 2006 年 Intel 开发 EFI, 苹果采用</li><li>2007 年 UEFI 问世, 统一标准</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/img/master/img/maxresdefault.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1980s 开始 BIOS 系统&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="Hackintosh" scheme="http://yoursite.com/categories/Hackintosh/"/>
    
    
  </entry>
  
  <entry>
    <title>环境变量</title>
    <link href="http://yoursite.com/wiki/Linux/env/"/>
    <id>http://yoursite.com/wiki/Linux/env/</id>
    <published>2019-11-12T08:14:06.000Z</published>
    <updated>2020-01-15T12:06:59.171Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/env.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/img/master/img/env.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>shell</title>
    <link href="http://yoursite.com/wiki/Linux/shell/"/>
    <id>http://yoursite.com/wiki/Linux/shell/</id>
    <published>2019-11-12T08:14:06.000Z</published>
    <updated>2020-01-21T08:39:05.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shell-原理"><a href="#Shell-原理" class="headerlink" title="Shell 原理"></a>Shell 原理</h2><p>系统提供 shell 给用户调用内核</p><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/LinuxShell.png" alt=""></p><p>执行过程:</p><ol><li>读取用户键盘指令</li><li>分析命令，以命令名作为文件名，并将其它参数改造为系统调用 <code>execve()</code> 内部处理所要求的形式 </li><li>终端进程调用 <code>fork()</code> 建立一个子进程</li><li>终端进程本身用系统调用 <code>wait4()</code> 来等待子进程完成(如果是后台命令，则不等待). 当子进程运行时调用 <code>execve()</code>，子进程根据文件名(即命令名)到目录中查找有关文件(这是命令解释程序构成的文件), 将它调入内存, 执行这个程序(解释这条命令)</li><li>如果命令末尾有&amp;号(后台命令符号), 则终端进程不用系统调用 <code>wait4()</code> 等待, 立即发提示符, 让用户输入下一个命令, 转 1 如果命令末尾没有 &amp; 号, 则终端进程要一直等待, 当子进程(即运行命令的进程)完成处理后终止, 向父进程(终端进程)报告, 此时终端进程醒来, 在做必要的判别等工作后, 终端进程发提示符, 让用户输入新的命令, 重复上述处理过程.</li></ol><h2 id="内置-Shell-命令"><a href="#内置-Shell-命令" class="headerlink" title="内置 Shell 命令"></a>内置 Shell 命令</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/linux_shell_cmd.png" alt=""></p><h2 id="Shell-navigation"><a href="#Shell-navigation" class="headerlink" title="Shell navigation"></a>Shell navigation</h2><p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/cli-navigation.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Shell-原理&quot;&gt;&lt;a href=&quot;#Shell-原理&quot; class=&quot;headerlink&quot; title=&quot;Shell 原理&quot;&gt;&lt;/a&gt;Shell 原理&lt;/h2&gt;&lt;p&gt;系统提供 shell 给用户调用内核&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ra
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>unix 哲学</title>
    <link href="http://yoursite.com/wiki/Linux/unix/"/>
    <id>http://yoursite.com/wiki/Linux/unix/</id>
    <published>2019-11-12T08:14:06.000Z</published>
    <updated>2020-01-15T12:06:59.172Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/Unix%E5%93%B2%E5%AD%A6" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Unix%E5%93%B2%E5%AD%A6</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Unix%E5%93%B2%E5%AD%A6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/wiki/Unix%E5%93%B2
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>shell navigation</title>
    <link href="http://yoursite.com/wiki/Linux/shell_navigation/"/>
    <id>http://yoursite.com/wiki/Linux/shell_navigation/</id>
    <published>2019-11-12T08:14:06.000Z</published>
    <updated>2020-01-21T08:36:22.633Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/taizilongxu/img/master/img/cli-navigation.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/taizilongxu/img/master/img/cli-navigation.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
</feed>
